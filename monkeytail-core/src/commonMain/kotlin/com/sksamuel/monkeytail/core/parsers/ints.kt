package com.sksamuel.monkeytail.core.parsers

import com.sksamuel.monkeytail.core.validation.invalid
import com.sksamuel.monkeytail.core.validation.valid

/**
 * Chains a [Parser] to convert String? -> Int.
 * An input of type
 */
fun <I, E> Parser<I, String, E>.int(ifError: (String) -> E): Parser<I, Int, E> =
   flatMap {
      val i = it.toIntOrNull()
      i?.valid() ?: ifError(it).invalid()
   }

fun <I, E> Parser<I, Int, E>.positive(ifError: (Int) -> E): Parser<I, Int, E> =
   flatMap {
      if (it > 0) it.valid() else ifError(it).invalid()
   }

fun <I, E> Parser<I, Int, E>.nonneg(ifError: (Int) -> E): Parser<I, Int, E> =
   flatMap {
      if (it >= 0) it.valid() else ifError(it).invalid()
   }

fun <I, E> Parser<I, Int, E>.negative(ifError: (Int) -> E): Parser<I, Int, E> =
   flatMap {
      if (it < 0) it.valid() else ifError(it).invalid()
   }

fun <I, E> Parser<I, Int, E>.inrange(range: IntRange, ifError: (Int) -> E): Parser<I, Int, E> =
   flatMap {
      if (it in range) it.valid() else ifError(it).invalid()
   }

/**
 * Extends a [Parser] of output type string to parse that string into a double.
 * If the string cannot be parsed into a double, then the error is generated by the
 * given function [ifError].
 *
 * Note: This parser accepts nullable inputs if the receiver accepts nullable inputs
 * and a null is considered a failing case.
 */
fun <I, E> Parser<I, String, E>.long(ifError: (String) -> E): Parser<I, Long, E> =
   flatMap {
      val l = it.toLongOrNull()
      l?.valid() ?: ifError(it).invalid()
   }
