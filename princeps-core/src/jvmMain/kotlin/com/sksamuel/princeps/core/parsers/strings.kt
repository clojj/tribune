package com.sksamuel.princeps.core.parsers


/**
 * Modifies the output of a String producing [Parser] by trimming the output string
 * to remove prefix and suffix whitespace.
 *
 * @return the output of the underlying parser with whitespace trimmed.
 */
fun <I, E> Parser<I, String, E>.trim(): Parser<I, String, E> = map { it.trim() }

/**
 * Modifies the output of a String producing [Parser] to strip the given [chars].
 */
fun <I, E> Parser<I, String, E>.strip(chars: CharArray): Parser<I, String, E> =
   map { chars.fold(it) { acc, c -> acc.replace(c.toString(), "") } }

/**
 * Constrains a String producing parser to ensure it matches the given [regex].
 */
fun <I, E> Parser<I, String, E>.match(regex: Regex, ifError: (String) -> E): Parser<I, String, E> =
   filter({ it.matches(regex) }, ifError)


/**
 * Modifies a String -> String [Parser] by uppercasing the output string.
 *
 * @return the output of the underlying parser with the output uppercased.
 */
fun <I, E> Parser<I, String, E>.uppercase(): Parser<I, String, E> = map { it.uppercase() }

/**
 * Modifies a String -> String [Parser] by lowercasing the output string.
 *
 * @return the output of the underlying parser with the output lowercased.
 */
fun <I, E> Parser<I, String, E>.lowercase(): Parser<I, String, E> = map { it.lowercase() }

/**
 * Narrows an existing String -> String [Parser] by enforcing a max length on the input string.
 *
 * For strings which have length longer than the given [len] arguments, an invalid is
 * returned with the error message generated by [ifError].
 *
 * @param len the max length, inclusive
 * @param ifError the error generating function
 *
 * @return valid if the input string is less than or equal to [len] or an invalid otherwise.
 */
fun <I, E> Parser<I, String, E>.maxlen(len: Int, ifError: (String) -> E): Parser<I, String, E> =
   flatMap {
      when {
         it.length > len -> ifError(it).invalid()
         else -> it.valid()
      }
   }

/**
 * Narrows an existing String -> String [Parser] by enforcing an exact length on the input string.
 *
 * For strings which have length that differs than the given [len] arguments, an invalid is
 * returned with the error message generated by [ifError].
 *
 * @param len the max length, inclusive
 * @param ifError the error generating function
 *
 * @return valid if the input string is less than or equal to [len] or an invalid otherwise.
 */
fun <I, E> Parser<I, String, E>.length(len: Int, ifError: (String) -> E): Parser<I, String, E> =
   flatMap {
      when (it.length) {
         len -> it.valid()
         else -> ifError(it).invalid()
      }
   }

/**
 * Narrows an existing String -> String [Parser] by enforcing a min length on the input string.
 *
 * For strings which have length shorter than the given [len] arguments, an invalid is
 * returned with the error message generated by [ifError].
 *
 * @param len the max length, inclusive
 * @param ifError the error generating function
 *
 * @return valid if the input string is greater than or equal to [len] or an invalid otherwise.
 */
fun <I, E> Parser<I, String, E>.minlen(len: Int, ifError: (String) -> E): Parser<I, String, E> =
   flatMap {
      when {
         it.length < len -> ifError(it).invalid()
         else -> it.valid()
      }
   }

/**
 * Composes an existing String? producing [Parser] to reject nulls as errors.
 * In addition, also rejects blank strings. Error messages are generated by
 * the given function [ifError].
 *
 * @param ifError the error generating function used if the input is null or blank.
 *
 * @return valid if the input string is not null and not blank, otherwise invalid
 */
fun <I, E> Parser<I, String?, E>.notNullOrBlank(ifError: () -> E): Parser<I, String, E> {
   return flatMap { if (it.isNullOrBlank()) ifError().invalid() else it.valid() }
}

/**
 * Wraps an existing String -> String [Parser] to reject blank strings,
 * with the error message generated by the given function [ifBlank].
 *
 * @param ifBlank the error generating function
 *
 * @return invalid if the input string contains only whitespace, otherwise valid
 */
fun <I, E> Parser<I, String, E>.notBlank(ifBlank: () -> E): Parser<I, String, E> {
   return flatMap {
      if (it.isBlank()) ifBlank().invalid() else it.valid()
   }
}

/**
 * Wraps an existing String -> String [Parser] to reject blank strings,
 * with the error message generated by the given function [ifBlank].
 *
 * Nulls are acceptable and passed through.
 *
 * @param ifBlank the error generating function
 *
 * @return invalid if the input string contains only whitespace, otherwise valid
 */
fun <I, E> Parser<I, String?, E>.nullOrNotBlank(ifBlank: () -> E): Parser<I, String?, E> {
   return flatMap {
      if (it == null) null.valid() else if (it.isBlank()) ifBlank().invalid() else it.valid()
   }
}
